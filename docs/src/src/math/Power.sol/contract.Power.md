# Power
[Git Source](https://github.com/DAObox/fantastic-spork/blob/e85e294b9aa197e65780cf42fd333d2b29d2cb82/src/math/Power.sol)

*https://github.com/bancorprotocol/contracts
Modified from the original by Slava Balasanov & Tarrence van As
Split Power.sol out from BancorFormula.sol
https://github.com/bancorprotocol/contracts/blob/c9adc95e82fdfb3a0ada102514beb8ae00147f5d/solidity/contracts/converter/BancorFormula.sol
Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements;
and to You under the Apache License, Version 2.0. "*


## State Variables
### version

```solidity
string public version = "0.3";
```


### ONE

```solidity
uint256 private constant ONE = 1;
```


### MAX_WEIGHT

```solidity
uint32 private constant MAX_WEIGHT = 1000000;
```


### MIN_PRECISION

```solidity
uint8 private constant MIN_PRECISION = 32;
```


### MAX_PRECISION

```solidity
uint8 private constant MAX_PRECISION = 127;
```


### FIXED_1
The values below depend on MAX_PRECISION. If you choose to change it:
Apply the same change in file 'PrintIntScalingFactors.py', run it and paste the results below.


```solidity
uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;
```


### FIXED_2

```solidity
uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;
```


### MAX_NUM

```solidity
uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;
```


### LN2_NUMERATOR
Auto-generated via 'PrintLn2ScalingFactors.py'


```solidity
uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;
```


### LN2_DENOMINATOR

```solidity
uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;
```


### OPT_LOG_MAX_VAL
Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'


```solidity
uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;
```


### OPT_EXP_MAX_VAL

```solidity
uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;
```


### maxExpArray
The values below depend on MIN_PRECISION and MAX_PRECISION. If you choose to change either one of them:
Apply the same change in file 'PrintFunctionBancorFormula.py', run it and paste the results below.


```solidity
uint256[128] private maxExpArray;
```


## Functions
### constructor


```solidity
constructor();
```

### power

General Description:
Determine a value of precision.
Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.
Return the result along with the precision used.
Detailed Description:
Instead of calculating "base ^ exp", we calculate "e ^ (log(base) * exp)".
The value of "log(base)" is represented with an integer slightly smaller than "log(base) * 2 ^ precision".
The larger "precision" is, the more accurately this value represents the real value.
However, the larger "precision" is, the more bits are required in order to store this value.
And the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").
This maximum exponent depends on the "precision" used, and it is given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".
Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.
This allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.
This functions assumes that "_expN < 2 ^ 256 / log(MAX_NUM - 1)", otherwise the multiplication should be replaced with a "safeMul".


```solidity
function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8);
```

### generalLog

Compute log(x / FIXED_1) * FIXED_1.
This functions assumes that "x >= FIXED_1", because the output would be negative otherwise.


```solidity
function generalLog(uint256 _x) internal pure returns (uint256);
```

### floorLog2

Compute the largest integer smaller than or equal to the binary logarithm of the input.


```solidity
function floorLog2(uint256 _n) internal pure returns (uint8);
```

### findPositionInMaxExpArray

The global "maxExpArray" is sorted in descending order, and therefore the following statements are equivalent:
- This function finds the position of [the smallest value in "maxExpArray" larger than or equal to "x"]
- This function finds the highest position of [a value in "maxExpArray" larger than or equal to "x"]


```solidity
function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8);
```

### generalExp

This function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.
It approximates "e ^ x" via maclaurin summation: "(x^0)/0! + (x^1)/1! + ... + (x^n)/n!".
It returns "e ^ (x / 2 ^ precision) * 2 ^ precision", that is, the result is upshifted for accuracy.
The global "maxExpArray" maps each "precision" to "((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1".
The maximum permitted value for "x" is therefore given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".


```solidity
function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256);
```

### optimalLog

Return log(x / FIXED_1) * FIXED_1
Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1
Auto-generated via 'PrintFunctionOptimalLog.py'


```solidity
function optimalLog(uint256 x) internal pure returns (uint256);
```

### optimalExp

Return e ^ (x / FIXED_1) * FIXED_1
Input range: 0 <= x <= OPT_EXP_MAX_VAL - 1
Auto-generated via 'PrintFunctionOptimalExp.py'


```solidity
function optimalExp(uint256 x) internal pure returns (uint256);
```

